#!/usr/bin/env python3 
# -*- coding: utf-8 -*-"
"""
This file is part of the CBT (Core Brim Tech) project, https://www.corebrimtech.com

Copyright (c) 2024 | MOMODU KAMARA-KOLLEH

Advanced Evasion Engine with Behavioral Analysis
"""
import random, time, hashlib, base64, json
from urllib.parse import quote, unquote, urlparse
import re

class AdvancedEvasion(object):
    """Advanced evasion with behavioral analysis and dynamic adaptation"""
    
    def __init__(self, ufonet):
        self.ufonet = ufonet
        self.waf_signatures = {}
        self.block_patterns = []
        self.evasion_history = []
        self.success_rate = {}
        self.adaptive_delays = {}
        
    def analyze_waf_response(self, response, target):
        """Analyze WAF response to identify blocking patterns"""
        if target not in self.waf_signatures:
            self.waf_signatures[target] = {
                'blocked': False,
                'waf_type': None,
                'patterns': []
            }
        
        # Common WAF signatures
        waf_patterns = {
            'cloudflare': ['cf-ray', 'cloudflare', '__cf_bm'],
            'akamai': ['akamai', 'akamaighost'],
            'incapsula': ['incapsula', 'visid_incap'],
            'sucuri': ['sucuri', 'x-sucuri-id'],
            'aws_waf': ['aws', 'x-amzn-requestid'],
            'mod_security': ['mod_security', 'this error was generated by mod_security'],
            'barracuda': ['barracuda'],
            'fortinet': ['fortigate', 'fortinet']
        }
        
        response_lower = str(response).lower()
        headers = response.headers if hasattr(response, 'headers') else {}
        
        for waf_name, patterns in waf_patterns.items():
            for pattern in patterns:
                if pattern in response_lower or pattern in str(headers).lower():
                    self.waf_signatures[target]['waf_type'] = waf_name
                    self.waf_signatures[target]['blocked'] = True
                    print(f"[Info] [AI] [Evasion] Detected WAF: {waf_name}")
                    return waf_name
        
        # Check for block indicators
        block_indicators = ['403', 'forbidden', 'blocked', 'access denied', 'rate limit']
        for indicator in block_indicators:
            if indicator in response_lower:
                self.waf_signatures[target]['blocked'] = True
                return 'unknown'
        
        return None
    
    def generate_dynamic_payload(self, base_payload, waf_type=None):
        """Generate dynamic payload based on WAF type"""
        payload = base_payload
        
        if waf_type == 'cloudflare':
            # Cloudflare specific evasion
            payload = self.cloudflare_evade(payload)
        elif waf_type == 'akamai':
            payload = self.akamai_evade(payload)
        elif waf_type == 'mod_security':
            payload = self.modsec_evade(payload)
        else:
            # Generic evasion
            payload = self.generic_evade(payload)
        
        return payload
    
    def cloudflare_evade(self, payload):
        """Cloudflare-specific evasion techniques"""
        # Use Cloudflare Workers bypass
        # Fragment requests
        # Use HTTP/2 multiplexing
        # Rotate IPs frequently
        payload = self.fragment_payload(payload)
        payload = self.add_legitimate_headers(payload)
        return payload
    
    def akamai_evade(self, payload):
        """Akamai-specific evasion"""
        # Use Akamai edge server behavior
        # Cache poisoning techniques
        payload = self.cache_poison(payload)
        return payload
    
    def modsec_evade(self, payload):
        """ModSecurity evasion"""
        # Use encoding bypasses
        # Fragment SQL/command injection
        payload = self.encoding_bypass(payload)
        return payload
    
    def generic_evade(self, payload):
        """Generic evasion techniques"""
        techniques = [
            self.unicode_encode,
            self.hex_encode,
            self.double_encode,
            self.case_variation,
            self.comment_injection
        ]
        
        # Apply random techniques
        for technique in random.sample(techniques, random.randint(1, 3)):
            payload = technique(payload)
        
        return payload
    
    def unicode_encode(self, payload):
        """Unicode encoding bypass"""
        return payload.encode('unicode_escape').decode('utf-8')
    
    def hex_encode(self, payload):
        """Hex encoding"""
        return ''.join(f'\\x{ord(c):02x}' for c in payload)
    
    def double_encode(self, payload):
        """Double URL encoding"""
        return quote(quote(payload))
    
    def case_variation(self, payload):
        """Random case variation"""
        return ''.join(random.choice([c.upper(), c.lower()]) for c in payload)
    
    def comment_injection(self, payload):
        """SQL/command comment injection"""
        comments = ['/**/', '--', '/*', '*/', '#']
        if random.random() > 0.5:
            payload = payload.replace(' ', random.choice(comments))
        return payload
    
    def fragment_payload(self, payload, chunk_size=100):
        """Fragment payload into smaller chunks"""
        chunks = []
        for i in range(0, len(payload), chunk_size):
            chunks.append(payload[i:i+chunk_size])
        return chunks
    
    def add_legitimate_headers(self, payload):
        """Add legitimate-looking headers"""
        headers = {
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'DNT': '1',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        }
        return payload, headers
    
    def cache_poison(self, payload):
        """Cache poisoning techniques"""
        # Add cache-control headers
        # Use X-Forwarded-Host manipulation
        return payload
    
    def encoding_bypass(self, payload):
        """Multiple encoding bypasses"""
        encodings = [
            lambda x: base64.b64encode(x.encode()).decode(),
            lambda x: quote(x),
            lambda x: x.encode('utf-8').hex()
        ]
        encoding = random.choice(encodings)
        return encoding(payload)
    
    def behavioral_evasion(self, target, request_count):
        """Adaptive behavioral evasion based on patterns"""
        if target not in self.adaptive_delays:
            self.adaptive_delays[target] = 1.0
        
        # Learn from previous requests
        if request_count > 10:
            # Increase delay if getting blocked
            if self.success_rate.get(target, 1.0) < 0.5:
                self.adaptive_delays[target] *= 1.5
            else:
                self.adaptive_delays[target] *= 0.9
        
        # Randomize delay
        delay = self.adaptive_delays[target] * random.uniform(0.8, 1.2)
        return max(0.1, min(delay, 10.0))  # Cap between 0.1 and 10 seconds
    
    def protocol_level_obfuscation(self, request_data):
        """Protocol-level obfuscation"""
        # HTTP/1.1 vs HTTP/2 switching
        # Header order randomization
        # Chunked transfer encoding
        # Compression variations
        
        obfuscated = request_data.copy()
        
        # Randomize header order
        if 'headers' in obfuscated:
            headers_list = list(obfuscated['headers'].items())
            random.shuffle(headers_list)
            obfuscated['headers'] = dict(headers_list)
        
        # Add chunked encoding
        if random.random() > 0.7:
            obfuscated['chunked'] = True
        
        return obfuscated
    
    def traffic_pattern_randomization(self, base_pattern):
        """Randomize traffic patterns to avoid detection"""
        patterns = {
            'burst': lambda: [1, 1, 1, 0.5, 0.5],  # Burst then slow
            'steady': lambda: [1] * 10,  # Steady rate
            'random': lambda: [random.uniform(0.5, 2.0) for _ in range(10)],
            'human': lambda: [random.uniform(1.5, 4.0) for _ in range(10)]  # Human-like
        }
        
        pattern_type = random.choice(list(patterns.keys()))
        return patterns[pattern_type]()
    
    def comprehensive_evade(self, target, payload, response=None):
        """Comprehensive evasion combining all techniques"""
        waf_type = None
        if response:
            waf_type = self.analyze_waf_response(response, target)
        
        # Generate dynamic payload
        evaded_payload = self.generate_dynamic_payload(payload, waf_type)
        
        # Protocol-level obfuscation
        request_data = {
            'payload': evaded_payload,
            'headers': {},
            'delay': self.behavioral_evasion(target, len(self.evasion_history))
        }
        request_data = self.protocol_level_obfuscation(request_data)
        
        # Record evasion attempt
        self.evasion_history.append({
            'target': target,
            'waf_type': waf_type,
            'timestamp': time.time(),
            'success': None  # Will be updated after request
        })
        
        return request_data
